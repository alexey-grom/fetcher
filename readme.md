fetcher
=============

Описание
-------------

fetcher - фреймворк для быстрой разработки пауков, сливающих контент и (или) взаимодействующих с сайтами посредством специфичных запросов.

Список возможностей:
* полная реализация http-протокола, за счет использования библиотеки curl в качестве транспорта
* хранение списка задач в оперативной памяти или MongoDB
* обработка групп задач
* сохранение ответов сервера в оперативную память, файл или автоматический выбор лучшего варианта
* подавление ошибок и нестандартных ситуаций и возможность пользовательской обработки ошибок
* кеширование ответов сервера в файлы, MongoDB или MySQL
* фронтэнд на Flask с админкой для управления пауком и просмотра моделей
* расширения для удобного взаимодействия с lxml и v8
* расширение для взаимодействиями с формами
* структурный парсинг упрощающий извлечение структурированных но многочисленных данных на страницах

Фреймворк исключительно экспериментальный, не предназначен для широкого использования, покрытие тестами нулевое, обратной совместимости между версиями нет и не будет никогда.


Общая архитектура
-------------

Архитектура, в целом, скопирована с фреймворка для парсинга сайтов [Grab](http://grablib.org/) ([репозиторий](https://bitbucket.org/lorien/grab)), с приоритетом на рациональное расходование оперативной памяти и разработку исключительно пауков, без синхронного интерфейса. <br />
Каждый паук является наследником класса MultiFetcher, который содержит очередь задач, расширение для реализации кэша и диспетчер http-запросов. <br />
В зависимости от настроек, очередь задач независима от своего местонахождения и может хранить задачи как в базе данных, так и в оперативной памяти. То же относится и к расширению для реализации кэширования, за исключением того, что кэш может хранится, кроме БД, еще в файлах на жестком диске. <br />
Вся полезная работа пауков реализуется посредством создания задач (класс Task), содержащих, как обязательные компоненты, хэндлер задачи, класс запроса и класс ответа сервера. Кроме того, задача может содержать пользовательские атрибуты. <br />
В классе запроса (Request) хранятся, как то следует из названия, все атрибуты будущего запроса: url, метод, User-Agent, Referer и т.д. Кроме того, хранятся настройки для сохранения ответа сервера: т.к. ответ сервера может быть большим или необходимым только для сохранения в файл, изначальное скачивание ответа в файл может быть более предпочтительным, чем скачивание в оперативную память. <br />
После выполнения каждой задачи, вызывается её обработчик, определяемый по хэндлеру задачи. Если по хэндлеру не найден обработчик - задача отправляется в коллектор. <br />
Задачи можно создать тремя путями: созданием отдельного генератора задач, генерируя задачи из обработчиков задач и добавляя задачи непосредственно в очередь задач текущего паука. <br />


Кэширование
-------------

Фреймворк предоставляет готовые бекэнды для кэширования ответов сервера в mongo, БД подключаемую через SQLAlchemy или файлы на жестком диске. <br />

Для включения кэширования в конструктор класса MultiFetcher необходимо передать имя бекэнда:

    spider = MultiFetcher(
        cache_backend='file', # или 'mongo', или 'sqla'
        cache_path='/tmp/spider-cache/'
    )

Кроме того, каждый бекэнд требует дополнительные параметры для инициализации.
Дополнительные параметры:
* file: cache_path - путь куда будут сохранятся ответы сервера. по-умолчанию '/tmp/fetcher-cache'
* mongo: cache_database - имя БД. по-умолчанию 'FetcherCache'
* sqla: cache_uri - URI для подключения к БД

Если есть необходимость написать свой бекэнд для хранения ответов сервера, это можно сделать через наследование класса `fetcher.cache.BaseCacheBackend` и передачу этого класса в параметре cache_backend при инициализации MultiFetcher. <br />

    spider = MultiFetcher(
        cache_backend=YourCacheBackendClassName
    )

Кэшированием управляет расширение `fetcher.cache.CacheExtension` и оно может быть выключенным, либо работать в двух режимах: простое сохранение ответа и браузерное кэширование. <br />
Браузерное кеширование, в отличии от простого сохранения ответов на все запросы, кэширует только те ответы, которые допустимо (простые GET-запросы) и ориентируется на http-заголоки с указаниями от сервера. <br />
Режим кэширования можно установить при создании класса MultiFetcher передав ему параметр cache_type с одим из следующих значений:
* CACHE_NONE - кэширование отключено
* CACHE_RESPONSE - простое сохранение тела ответов сервера, по-умолчанию
* CACHE_TRUE - браузерное кэширование
